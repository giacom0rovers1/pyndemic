Spanning tree:
    random tree che collega tutti i nodi del grafo
    
Percolazione
Perturbazioni
Rewiring

Degree distribution
Centrality
Communities
Clustering
Stratification

Disease/information spreading
Ranking

Ensembles --> meccanica statistica dei networks


Efficiency (?) vs Spectral Centrality
    Risposta dinamica agli attacchi (rimozione)?


NO LOOPS - NO Multigraphs (piuttosto weights)


** Matrice di Adiacenza {NxN} (N = numero di nodi) **
Aij = 1 se c'è link, 0 se no
Aii = 0 (no loops)

Grafo pesato
Aij = wij peso della connessione (importanza, larghezza)

Grafo directed/undirected
A == A' non diretto (matrice simmetrica)
A != A' diretto

Grafo bipartito: 
    due tipi di nodi connessi (matrice primo e terzo quadrante)
    

** Matrice di Incidenza I {nxN} (n = numero di links) **
Se Aij != 0, Iki = -1 e Ikj = 1 per il k-esimo link del grafo diretto dal nodo i-esimo al nodo j-esimo

Se ho un vettore f di valori associati ai nodi, la matrice I applicata ad f calcola una differenza orientata tra i valori di f su nodi adiacenti (collegati dal grafo): I operatore derivata generalizzata


** Matrice dei links (edge matrix) E {nx2} **
[En1 = nodo di partenza, En2 = nodo di arrivo]
Utile per matrici sparse: n = o(N^2) numero di link più piccolo del quadrato del numero di nodi


** Matrice dei nodi (vertex matrix) V {Nx?} (è più una list() che una matrice) **
Vi = (id1 id2 id3 ...) per ogni nodo sono indicati i nodi raggiungibili
utile per processi diffusivi (walks)


** Matrice del Degree D {NxN} **
Dii = ki = Sumj(Aij)  somme riga (o colonna) = degree dei nodi (connettività)
Dij = 0 per i != j


** MATRICE LAPLACIANA L = D - A **
Lij = -Aij per i != j
Lii = Dii = ki

I' * I = L





Isomorfismo: permutazione degli indici dei nodi, la struttura deil links non cambia

La matrice di permutazione P e` una permutazione delle righe della matrice identita` (un solo 1 per riga e per colonna, ma non per forza sulla diagonale)
Esistono N! matrici di permutazione NxN, quindi N! networks isomorfi.
Sfrutto questa proprieta` per riodinare i nodi secondo le esigenze di visualizzazione o di raggruppamento (re-indexing)

Ap = P * A * P'
Vp = P * V
P P' = 1


Walk  = cammino tra due nodi 
Trail = walk senza passare due volte sullo stesso link 
Path  = trail senza passare due volte dallo stesso nodo
Cycle = path chiuso

Length        = # di links percorsi
Girth         = shortest possible cycle (if any) in the graph
Circumference = longest possible cycle (if any)

Connessione: da qualunque nodo riesco ad arrivare a qualunque altro. Altrimenti, blocchi diagonali.

With increased connection:
Spanning semiwalk (directed) -> Spanning walk (directed) -> Spanning closed walk (undirected)
Spanning tree (scelgo solo i link che formano un tree tra quelli disponibili, e` il piu` piccolo grafo che connetta tutti i vertici)


NODE DISTANCE: shortest path tra due nodi
D(u,v) = 0 se u = v
D(u,v) = 1 se adiacenti
D(u,v) = Inf se disconnessi

Metrica su grafo semidefinita positiva, simmetrica e per la quale vale la disuguaglianza triangolare

WEIGHTED NODE DISTANCE composizione armonica dei pesi
dij = Sum(1/wkl) dove wkl sono i pesi dei link dei path dal nodo i al nodo j


SHORTEST PATH: geodetica tra due nodi
Diameter: geodetica massima in un grafo
Average Path Length L: media su tutti gli shortest paths (Dijkstra algorithm)


(CONNECTIVITY) DEGREE
Ki = Sumj(Aij) somme riga: quanti link sono connessi a un nodo

maxK = N-1


K-Clique
Sottografo di G completamente connesso con degree K


